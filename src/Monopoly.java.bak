import java.text.ParseException;

import data.object.*;
import data.module.*;
import data.global.*;

public class Monopoly {
	
	public static void main(String[] args) {
		Window.showGreeting();
		initialize();
		start();
	}
	
	static boolean endRound = false;
	
	private static void start() {
		while (true) {
			for (int i = 1; i < Game.players.length; i++) {   // one round
				endRound = false;
				while (!endRound) {          // break if one player finish
					Window.showDateInfo();
					Window.showMenu();
					menuSelection();
				}
			}	
			Time.nextDay();
			if (Time.endOfMonth()) {
				// fa li xi
			}
		}
	}

	
	/** initialize the players, map, time 
	 * // to give them values != create them */
	public static void initialize() {
		setPlayers();
		setMap();
		setTime();
	}
	
	/** Enable user to set player's name and give an icon */
	public static void setPlayers() {
		for (int i = 1; i < Game.players.length; i++) {
			Window.nameInputForPlayer(i);
			Game.players[i].name = Helper.getStr();
			if (i < Vocab.PlayerIcon.length) {
				Game.players[i].icon = Vocab.PlayerIcon[i];
			} // else player.icon will be a default value "\u3000\u3000"
		}
	}
	
	/** Enable user to set map by random //or himself */
	public static void setMap() {
		do {
			Game.map.clear();
			Game.map.generateByRandom();
			Game.map.update();
			Game.map.show();
			Window.showMapRegeneratePrompt();
		} while (Helper.getStr().equals("r"));
		System.arraycopy(Game.map.image, 0, Game.mapWithInfo.image, 0, Game.map.image.length);
		System.arraycopy(Game.map.route, 0, Game.mapWithInfo.route, 0, Game.map.route.length);
	}
	
	public static void setTime() {
  		try {
  			Game.date = Game.dateFormat.parse("2014-01-01");
  		    Game.dateCalendar.setTime(Game.date);
  		} catch (ParseException e) {
  		}
	}
	
	public static void menuSelection() {
		switch (Helper.getInt(0, Vocab.Command.length - 1)) {
		case 0: showMapWithInfo();       break;
		case 1: showMap();               break;
		case 2:                          break;
		case 3: showBarrierIn10Steps();  break;
		case 4: showInfoOfCertainCell(); break;
		case 5: showPlayersInfo();       break;
		case 6: diceAndGo();             break;
		case 7: endGame();
		}

	}
	
	// Selection methods
	private static void showMapWithInfo() {
		Game.mapWithInfo.update();
		Game.mapWithInfo.addPlayersInfo();
		Game.mapWithInfo.show(); 
	}
	
	private static void showMap() {
		Game.map.show(); 
	}
	
	private static void showBarrierIn10Steps() {
		Window.showBarrier(10);
	}
	
	private static void showInfoOfCertainCell() {
		Window.StepInputPrompt();
		String str_deltaStep = Helper.getStr(); 
		int deltaStep = 0;
		try {
			while (true) {
				deltaStep = Integer.parseInt(str_deltaStep);
				Window.showCellInfo(deltaStep);
				Window.StepInputPrompt();
				str_deltaStep = Helper.getStr(); 
			}
		} catch (NumberFormatException e) {
		}
	}
	
	private static void showPlayersInfo() {
		Window.showPlayersInfo();
	}
	
	private static void diceAndGo() {
		int step = dice();
		Window.showDiceInfo(step);
		Game.players[Game.currentPlayer].location += step * Game.players[Game.currentPlayer].direction;
		Game.players[Game.currentPlayer].location = Helper.ensure(Game.players[Game.currentPlayer].location);
		showMapWithInfo();
		caseLocation();
		switchPlayer();
		endRound = true;
	}
	
	//==============================

	
	
	private static void caseLocation() {
		// TODO Auto-generated method stub
		
	}


	private static int dice() {
		return Helper.rand(6) + 1; 
	}
	
	private static void switchPlayer() {
		Game.currentPlayer = 3 - Game.currentPlayer;
	}
	
	public static void endGame() {
		switchPlayer();
		Window.showEndGameWithWinOf(Game.players[Game.currentPlayer]);
		//Helper.getStr();
		System.exit(0);
	}
}
